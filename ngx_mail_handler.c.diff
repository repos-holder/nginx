$dukzcry$
--- nginx-1.0.11/src/mail/ngx_mail_handler.c	2011-09-23 03:32:23.000000000 +0400
+++ nginx-1.0.11/src/mail/ngx_mail_handler.c.new	2014-02-24 07:58:30.000000000 +0400
@@ -13,8 +13,13 @@
 static void ngx_mail_init_session(ngx_connection_t *c);
 
 #if (NGX_MAIL_SSL)
-static void ngx_mail_ssl_init_connection(ngx_ssl_t *ssl, ngx_connection_t *c);
 static void ngx_mail_ssl_handshake_handler(ngx_connection_t *c);
+/* ssl_concurrent_reuse */
+static ngx_int_t ngx_mail_add_concurrent(ngx_mail_session_t *);
+static void ngx_mail_free_concurrent(ngx_mail_session_t *);
+static void ngx_mail_wait_concurrent_handshake_handler(ngx_connection_t *);
+static void ngx_mail_wait_concurrent_unlock_handler(ngx_connection_t *);
+/* */
 #endif
 
 
@@ -149,6 +154,7 @@ ngx_mail_init_connection(ngx_connection_
 
 #if (NGX_MAIL_SSL)
     {
+
     ngx_mail_ssl_conf_t  *sslcf;
 
     sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);
@@ -156,7 +162,8 @@ ngx_mail_init_connection(ngx_connection_
     if (sslcf->enable) {
         c->log->action = "SSL handshaking";
 
-        ngx_mail_ssl_init_connection(&sslcf->ssl, c);
+        ngx_mail_ssl_init_connection(&sslcf->ssl, c,
+	    NGX_MAIL_SECURE_DIR_IN);
         return;
     }
 
@@ -172,7 +179,8 @@ ngx_mail_init_connection(ngx_connection_
             return;
         }
 
-        ngx_mail_ssl_init_connection(&sslcf->ssl, c);
+        ngx_mail_ssl_init_connection(&sslcf->ssl, c,
+	    NGX_MAIL_SECURE_DIR_IN);
         return;
     }
 
@@ -184,6 +192,243 @@ ngx_mail_init_connection(ngx_connection_
 
 
 #if (NGX_MAIL_SSL)
+static ngx_int_t
+ngx_mail_add_concurrent(ngx_mail_session_t *s)
+{
+    ngx_connection_t *c = s->connection;
+    ngx_mail_core_main_conf_t *cmcf = ngx_mail_get_module_main_conf(s,
+	ngx_mail_core_module);
+
+    if (ngx_event_mutex_lock(&cmcf->ssl_concurrent_lock,
+	    c->read, 0, c->log) != NGX_OK) // prototype
+    {
+	c->ssl->handler = ngx_mail_wait_concurrent_unlock_handler;
+	return NGX_AGAIN;
+    }
+
+    ngx_list_t *list = cmcf->ssl_concurrent_reuse;
+    ngx_list_part_t *part = cmcf->ssl_concurrent_reuse->partp;
+    ngx_ssl_concurrent_reuse_t *list_elm;
+
+    ngx_str_t *client = ((ngx_mail_log_ctx_t *)c->log->data)->client;
+    ngx_str_t *server = s->addr_text;
+
+    if (!part->nelts) {
+	ngx_log_debug2(NGX_LOG_DEBUG_MAIL, c->log, 0,
+	    "ssl add concurrent reuse: init");
+	goto push;
+    }
+
+    ngx_log_debug2(NGX_LOG_DEBUG_MAIL, c->log, 0,
+	"session: %V, %V", client, server);
+
+    /* kill da zombies */
+    /*void *p = cmcf->ssl_concurrent_pool->d.last;
+    (ngx_ssl_concurrent_reuse_t *) p = (char *) p -
+	list->size * (list->nalloc - (list->last->nelts - 1));
+    while (1) {
+	ngx_log_debug2(NGX_LOG_DEBUG_MAIL, c->log, 0,
+	    "cleanup: finished %d, counter %d",
+	    ((ngx_ssl_concurrent_reuse_t *) p)->finished,
+	    ((ngx_ssl_concurrent_reuse_t *) p)->counter);
+
+	if ( ((ngx_ssl_concurrent_reuse_t *) p)->finished &&
+	     !((ngx_ssl_concurrent_reuse_t *) p)->counter)
+	{
+	    if (list->nalloc > 1) {
+		list->last->nelts--;
+
+		if (list->last->nelts) {
+		    (ngx_ssl_concurrent_reuse_t *) p = (char *) p -
+			list->size;
+		    continue;
+		}
+	    }
+	
+	    (ngx_list_part_t *) p = (char *) p -
+		sizeof(ngx_list_part_t);
+
+	    ngx_list_part_t *prev = ((ngx_list_part_t *) p)->prev;
+	    if (prev) {*/
+		/* part + elts will be re-allocated */
+		/*cmcf->ssl_concurrent_pool->d.last = p;
+		list->last = prev;
+		prev->next = NULL;
+	    }
+	    else {
+		((ngx_list_part_t *)p)->nelts = 0;
+		goto push;
+	    }
+	}
+	else break;
+	
+	(ngx_ssl_concurrent_reuse_t *) p = (char *) p - list->size;
+    }*/
+    
+    ngx_uint_t i;
+    list_elm = part->elts;
+    ngx_ssl_concurrent_reuse_t *data = NULL;
+    for (i = 0 ; ; i++) {
+	if (i >= part->nelts) {
+	    if (part->next == NULL)
+		break;
+	
+	    part = part->next;
+	    list_elm = part->elts;
+	    i = 0;
+	}
+	data = &list_elm[i];
+	ngx_log_debug2(NGX_LOG_DEBUG_MAIL, c->log, 0,
+	    "%d from list: %V, %V", i, &data->client_addr_text.str,
+		&data->server_addr_text.str);
+	
+	if (!ngx_strcmp(data->client_addr_text.str.data,
+			client)
+		&&
+	    !ngx_strcmp(data->server_addr_text.str.data,
+			server))
+	{
+		ngx_log_debug2(NGX_LOG_DEBUG_MAIL,
+		    c->log, 0, 
+		"ssl add concurrent reuse: dup elm. iter: %d, wait: %d",
+		    i, data->waiting);
+		    
+		s->ssl_concurrent_cur = data;
+		/* count our instance */
+		data->counter++;
+		data->finished = 0;
+		
+		ngx_event_mutex_unlock(&cmcf->ssl_concurrent_lock,
+		    c->log);
+		
+		if (data->waiting) {
+		    c->ssl->handler =
+			ngx_mail_wait_concurrent_handshake_handler;
+		    return NGX_AGAIN;
+		}
+		
+		return NGX_OK;
+	}
+    }
+    ngx_log_debug2(NGX_LOG_DEBUG_MAIL, c->log, 0, "KAL: %d, %d",
+	    cmcf->ssl_concurrent_pool->d.end -
+		    cmcf->ssl_concurrent_pool->d.last,
+	 ( (u_char *)( (char *) data + list->size +
+	 (part->nelts == list->nalloc ? sizeof(ngx_list_part_t) : 0) +
+	 list->size) >= cmcf->ssl_concurrent_pool->d.end)  );
+
+    /*if ((void *)( (char *) data + list->size +
+	(part->nelts == list->nalloc ? sizeof(ngx_list_part_t) : 0) +
+	list->size ) >= (void *) cmcf->ssl_concurrent_pool->d.end)
+    {
+	    ngx_log_debug2(NGX_LOG_DEBUG_MAIL, c->log, 0, "pool reset");
+	    ngx_reset_pool(cmcf->ssl_concurrent_pool);
+	    if ( (cmcf->ssl_concurrent_reuse = ngx_list_create(cmcf->
+		ssl_concurrent_pool, NGX_MAIL_SSL_REUSE_LIST_PART_SIZE,
+		    sizeof(ngx_ssl_concurrent_reuse_t)))
+		    == NULL)
+	    {
+			ngx_event_mutex_unlock(&cmcf->ssl_concurrent_lock,
+			    c->log);
+			return NGX_ERROR;
+	    }
+    }*/
+
+push:
+    list_elm = ngx_list_push(cmcf->ssl_concurrent_reuse);
+    if (!list_elm) {
+	ngx_log_debug2(NGX_LOG_DEBUG_MAIL, c->log, 0, "pool reset");
+	ngx_reset_pool(cmcf->ssl_concurrent_pool);
+	if ( (cmcf->ssl_concurrent_reuse = ngx_list_create(cmcf->
+	    ssl_concurrent_pool, NGX_MAIL_SSL_REUSE_LIST_PART_SIZE,
+		sizeof(ngx_ssl_concurrent_reuse_t)))
+		== NULL)
+	{
+	    ngx_event_mutex_unlock(&cmcf->ssl_concurrent_lock,
+		c->log);
+	    return NGX_ERROR;
+	}
+    }
+    
+    list_elm->client_addr_text.str.len = client->len;
+    list_elm->server_addr_text.str.len = server->len;
+    ngx_memcpy(list_elm->client_addr_text.data,
+		client->data, client->len);
+    ngx_memcpy(list_elm->server_addr_text.data,
+		server->data, server->len);
+    list_elm->client_addr_text.str.data =
+	(u_char *) &list_elm->client_addr_text.data;
+    list_elm->server_addr_text.str.data =
+	(u_char *) &list_elm->server_addr_text.data;
+    list_elm->waiting = list_elm->counter = 1;
+    list_elm->finished = 0;
+    
+    s->ssl_concurrent_cur = list_elm;
+    
+    ngx_log_debug2(NGX_LOG_DEBUG_MAIL, c->log, 0,
+	"ssl add concurrent reuse: new elm, cur: %p",
+	    s->ssl_concurrent_cur);
+    
+    ngx_event_mutex_unlock(&cmcf->ssl_concurrent_lock,
+	c->log);
+
+    return NGX_OK;
+}
+static void
+ngx_mail_free_concurrent(ngx_mail_session_t *s)
+{
+    ngx_mail_core_main_conf_t *cmcf = ngx_mail_get_module_main_conf(s,
+	ngx_mail_core_module);
+
+    if (!cmcf->ssl_concurrent_reuse)
+	return;
+
+    ngx_connection_t *c = s->connection;
+    ngx_ssl_concurrent_reuse_t *session = s->ssl_concurrent_cur;
+
+    /* i'm finished */
+    session->waiting = 0;
+    session->counter--;
+				
+    ngx_log_debug2(NGX_LOG_DEBUG_MAIL, c->log, 0,
+	    "ssl free concurrent reuse: cur: %p, cntr: %d",
+        	session, session->counter);
+}
+void
+ngx_mail_wait_concurrent_handshake_handler(ngx_connection_t *c)
+{
+    ngx_mail_session_t *s = c->data;
+    ngx_ssl_concurrent_reuse_t *session =
+	s->ssl_concurrent_cur;
+	
+    if (session->waiting)
+	return;
+	
+    if (ngx_ssl_handshake(c) == NGX_AGAIN)
+	c->ssl->handler = ngx_mail_ssl_handshake_handler;
+}
+void
+ngx_mail_wait_concurrent_unlock_handler(ngx_connection_t *c)
+{
+    ngx_mail_session_t *s = c->data;
+    ngx_mail_core_main_conf_t *cmcf;
+    ngx_int_t err;
+
+    cmcf = ngx_mail_get_module_main_conf(s, ngx_mail_core_module);
+    
+    if (ngx_event_mutex_lock(&cmcf->ssl_concurrent_lock, c->read,
+	    0, c->log) != NGX_OK)
+	return;
+    if ( (err = ngx_mail_add_concurrent(s)) != NGX_OK) {
+	if (err == NGX_ERROR) {
+	    ngx_mail_close_connection(c);
+	}
+    
+	return;
+    }
+    if (ngx_ssl_handshake(c) == NGX_AGAIN)
+	c->ssl->handler = ngx_mail_ssl_handshake_handler;
+}
 
 void
 ngx_mail_starttls_handler(ngx_event_t *rev)
@@ -200,66 +445,117 @@ ngx_mail_starttls_handler(ngx_event_t *r
 
     sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);
 
-    ngx_mail_ssl_init_connection(&sslcf->ssl, c);
+    ngx_mail_ssl_init_connection(&sslcf->ssl, c, NGX_MAIL_SECURE_DIR_IN);
 }
 
-
-static void
-ngx_mail_ssl_init_connection(ngx_ssl_t *ssl, ngx_connection_t *c)
+void
+ngx_mail_ssl_init_connection(ngx_ssl_t *ssl, ngx_connection_t *c, ngx_int_t direction)
 {
-    ngx_mail_session_t        *s;
-    ngx_mail_core_srv_conf_t  *cscf;
+    ngx_mail_session_t *s;
+    ngx_mail_core_srv_conf_t *cscf;
+    ngx_uint_t flags = 0;
+    
+    if (direction == NGX_MAIL_SECURE_DIR_OUT)
+	flags = NGX_SSL_BUFFER|NGX_SSL_CLIENT;
 
-    if (ngx_ssl_create_connection(ssl, c, 0) == NGX_ERROR) {
+    if (ngx_ssl_create_connection(ssl, c, flags) == NGX_ERROR) {
         ngx_mail_close_connection(c);
         return;
     }
 
-    if (ngx_ssl_handshake(c) == NGX_AGAIN) {
-
-        s = c->data;
+    c->ssl->spare_handshaked = 0;
 
-        cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
-
-        ngx_add_timer(c->read, cscf->timeout);
+    s = c->data;
+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
+    
+    ngx_int_t err;
+    
+    if (direction == NGX_MAIL_SECURE_DIR_IN &&
+	    cscf->ssl_session_reuse) {
+	if ( (err = ngx_mail_add_concurrent(s)) != NGX_OK) {
+	    if (err == NGX_ERROR)
+		ngx_mail_close_connection(c);
+
+	    return;
+	}
+    }
+    
+    err = ngx_ssl_handshake(c);
+    
+    if (direction == NGX_MAIL_SECURE_DIR_OUT && err == NGX_ERROR &&
+	c->ssl->spare_handshaked) {
+	ngx_mail_proxy_internal_server_error(s);
+	return;
+    }
+    if (err == NGX_AGAIN) {
+	/* expected that for upstream, one is set already */
+	if (direction == NGX_MAIL_SECURE_DIR_IN)
+	    ngx_add_timer(c->read, cscf->timeout);
 
-        c->ssl->handler = ngx_mail_ssl_handshake_handler;
+    	c->ssl->handler = ngx_mail_ssl_handshake_handler;
 
-        return;
+    	return;
     }
 
     ngx_mail_ssl_handshake_handler(c);
 }
 
-
-static void
+static 
+void
 ngx_mail_ssl_handshake_handler(ngx_connection_t *c)
 {
-    ngx_mail_session_t        *s;
+    ngx_mail_session_t        *s = c->data;
     ngx_mail_core_srv_conf_t  *cscf;
 
     if (c->ssl->handshaked) {
-
-        s = c->data;
-
+	cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
+    
         if (s->starttls) {
-            cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
 
             c->read->handler = cscf->protocol->init_protocol;
             c->write->handler = ngx_mail_send;
 
+	    if (cscf->ssl_session_reuse)
+		ngx_mail_free_concurrent(s);
             cscf->protocol->init_protocol(c->read);
 
             return;
         }
 
-        c->read->ready = 0;
-
-        ngx_mail_init_session(c);
+	/* temporary: tell client from server via buffer
+	 * creation checking */
+	if (c->ssl->buffer == 0) {
+	    c->read->ready = 0;
+
+	    if (cscf->ssl_session_reuse)
+		ngx_mail_free_concurrent(s);
+	    ngx_mail_init_session(c);
+	}
+	else if (!c->ssl->spare_handshaked) {
+	    c->ssl->spare_handshaked = 1;
+	    
+	    ngx_post_event(c->read, &ngx_posted_events);
+	    ngx_mail_proxy_start(c);
+	}
+	
         return;
     }
-
-    ngx_mail_close_connection(c);
+    else if (s->con_proto == NGX_MAIL_AUTH_PROTO_SECURE) {
+	ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,
+	    "auth_http asked for implicit secure connection to backend: " \
+	    "SSL failed, trying STARTTLS extension;");
+	c->ssl->no_wait_shutdown = c->ssl->no_send_shutdown = 1;
+	if (ngx_ssl_shutdown(c) == NGX_AGAIN)
+	    return;
+	ngx_post_event(c->read, &ngx_posted_events);
+	ngx_mail_proxy_start(c);
+	return;
+    }
+
+    if (c->ssl->buffer == 0)
+	ngx_mail_close_connection(c);
+    else
+	ngx_mail_proxy_internal_server_error(s);
 }
 
 #endif
@@ -541,14 +837,14 @@ ngx_mail_send(ngx_event_t *wev)
 
     c = wev->data;
     s = c->data;
-
+    
     if (wev->timedout) {
         ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, "client timed out");
         c->timedout = 1;
         ngx_mail_close_connection(c);
         return;
     }
-
+    
     if (s->out.len == 0) {
         if (ngx_handle_write_event(c->write, 0) != NGX_OK) {
             ngx_mail_close_connection(c);
@@ -595,7 +891,6 @@ ngx_mail_send(ngx_event_t *wev)
     }
 }
 
-
 ngx_int_t
 ngx_mail_read_command(ngx_mail_session_t *s, ngx_connection_t *c)
 {
@@ -700,6 +995,10 @@ ngx_mail_close_connection(ngx_connection
 
 #if (NGX_MAIL_SSL)
 
+    ngx_mail_session_t *s = c->data;
+    if (s->ssl_concurrent_cur)
+	s->ssl_concurrent_cur->finished = 1;
+
     if (c->ssl) {
         if (ngx_ssl_shutdown(c) == NGX_AGAIN) {
             c->ssl->handler = ngx_mail_close_connection;

$dukzcry$
--- nginx-1.0.11/src/mail/ngx_mail_proxy_module.c	2012-01-05 16:28:58.000000000 +0400
+++ nginx-1.0.11/src/mail/ngx_mail_proxy_module.c.new	2014-02-24 07:58:30.000000000 +0400
@@ -19,7 +19,6 @@ typedef struct {
     ngx_msec_t  timeout;
 } ngx_mail_proxy_conf_t;
 
-
 static void ngx_mail_proxy_block_read(ngx_event_t *rev);
 static void ngx_mail_proxy_pop3_handler(ngx_event_t *rev);
 static void ngx_mail_proxy_imap_handler(ngx_event_t *rev);
@@ -29,7 +28,6 @@ static ngx_int_t ngx_mail_proxy_read_res
     ngx_uint_t state);
 static void ngx_mail_proxy_handler(ngx_event_t *ev);
 static void ngx_mail_proxy_upstream_error(ngx_mail_session_t *s);
-static void ngx_mail_proxy_internal_server_error(ngx_mail_session_t *s);
 static void ngx_mail_proxy_close_session(ngx_mail_session_t *s);
 static void *ngx_mail_proxy_create_conf(ngx_conf_t *cf);
 static char *ngx_mail_proxy_merge_conf(ngx_conf_t *cf, void *parent,
@@ -72,7 +70,7 @@ static ngx_command_t  ngx_mail_proxy_com
       NGX_MAIL_SRV_CONF_OFFSET,
       offsetof(ngx_mail_proxy_conf_t, xclient),
       NULL },
-
+      
       ngx_null_command
 };
 
@@ -106,17 +104,14 @@ ngx_module_t  ngx_mail_proxy_module = {
 
 static u_char  smtp_auth_ok[] = "235 2.0.0 OK" CRLF;
 
-
 void
 ngx_mail_proxy_init(ngx_mail_session_t *s, ngx_addr_t *peer)
 {
     int                        keepalive;
-    ngx_int_t                  rc;
     ngx_mail_proxy_ctx_t      *p;
-    ngx_mail_proxy_conf_t     *pcf;
     ngx_mail_core_srv_conf_t  *cscf;
 
-    s->connection->log->action = "connecting to upstream";
+    s->connection->log->action = "initializing before connecting to upstream";
 
     cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
 
@@ -131,67 +126,152 @@ ngx_mail_proxy_init(ngx_mail_session_t *
                           "setsockopt(SO_KEEPALIVE) failed");
         }
     }
+#if (NGX_MAIL_SSL)
+    if (s->con_proto) {
+        ngx_mail_ssl_conf_t *sslcf;
+
+        sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);
+
+        if (sslcf->ssl.ctx == NULL)
+            ngx_log_error(NGX_LOG_WARN, s->connection->log, 0,
+                "no \"ssl_certificate\" is defined in mail section " \
+                "of config, while auth_http asked to use secure" \
+                "connection to backend;");
+    }
+#endif
 
     p = ngx_pcalloc(s->connection->pool, sizeof(ngx_mail_proxy_ctx_t));
     if (p == NULL) {
         ngx_mail_session_internal_server_error(s);
         return;
     }
-
+ 
     s->proxy = p;
 
-    p->upstream.sockaddr = peer->sockaddr;
     p->upstream.socklen = peer->socklen;
     p->upstream.name = &peer->name;
     p->upstream.get = ngx_event_get_peer;
     p->upstream.log = s->connection->log;
     p->upstream.log_error = NGX_ERROR_ERR;
+}
+
+int
+ngx_mail_proxy_postinit(ngx_mail_session_t *s, ngx_addr_t *peer, ngx_resolver_ctx_t *ctx)
+{
+    ngx_int_t rc;
+    ngx_mail_proxy_ctx_t *p = s->proxy;
+    ngx_mail_proxy_conf_t *pcf;
+    ngx_mail_core_srv_conf_t *cscf;
 
-    rc = ngx_event_connect_peer(&p->upstream);
+    s->connection->log->action = "connecting to upstream";
+    
+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
 
+    p->upstream.sockaddr = peer->sockaddr;
+   
+    if (!ctx)
+	rc = ngx_event_connect_peer(&p->upstream, NULL);
+    else {
+	struct timeval *timeout;
+	timeout = ngx_pcalloc(s->connection->pool, sizeof (struct timeval));
+	if (timeout == NULL) {
+	    ngx_mail_proxy_internal_server_error(s);
+	    return 0;
+	}
+	//ngx_memzero(&timeout->tv_sec, sizeof(timeout->tv_sec));
+	timeout->tv_sec = cscf->timeout / ctx->naddrs / 1000;
+	
+	rc = ngx_event_connect_peer(&p->upstream, timeout);
+	if (rc == NGX_ETIMEDOUT)
+	    return -1;
+    }
+	
     if (rc == NGX_ERROR || rc == NGX_BUSY || rc == NGX_DECLINED) {
-        ngx_mail_proxy_internal_server_error(s);
-        return;
+    	ngx_mail_proxy_internal_server_error(s);
+	return 0;
     }
 
     ngx_add_timer(p->upstream.connection->read, cscf->timeout);
 
-    p->upstream.connection->data = s;
     p->upstream.connection->pool = s->connection->pool;
+    p->upstream.connection->data = s;
 
     s->connection->read->handler = ngx_mail_proxy_block_read;
     p->upstream.connection->write->handler = ngx_mail_proxy_dummy_handler;
 
+    ngx_int_t secured = 0;
+#if (NGX_MAIL_SSL)
+    /* early explicit ssl */
+    if (s->con_proto == NGX_MAIL_AUTH_PROTO_SSL ||
+	    s->con_proto == NGX_MAIL_AUTH_PROTO_SECURE) {
+	s->connection->log->action = "SSL handshaking";
+    
+	ngx_mail_ssl_conf_t *sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);
+	if (sslcf->ssl.ctx) {
+    	    ngx_mail_ssl_init_connection(&sslcf->ssl,
+		    p->upstream.connection, NGX_MAIL_SECURE_DIR_OUT);
+	    secured = 1;
+	}
+	else {
+	    ngx_mail_proxy_internal_server_error(s);
+	    return 0;
+	}
+    }
+#endif
     pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
 
     s->proxy->buffer = ngx_create_temp_buf(s->connection->pool,
                                            pcf->buffer_size);
     if (s->proxy->buffer == NULL) {
         ngx_mail_proxy_internal_server_error(s);
-        return;
+        return 0;
     }
 
     s->out.len = 0;
 
-    switch (s->protocol) {
+    /* stls = set handler & state
+     * secure = handler will be set via ssl init routine */
+    if (s->con_proto == NGX_MAIL_AUTH_PROTO_STLS)
+	switch (s->protocol) {
+	    case NGX_MAIL_POP3_PROTOCOL:
+		s->mail_state = ngx_pop3_stls;
+		break;
+	    case NGX_MAIL_IMAP_PROTOCOL:
+		s->mail_state = ngx_imap_stls;
+		break;
+	}
+    if (!secured)
+	ngx_mail_proxy_start(p->upstream.connection);
+
+    return 0;
+}
+void ngx_mail_proxy_start(ngx_connection_t *p)
+{
+    ngx_mail_session_t *s = p->data;
+
+switch (s->protocol) {
 
     case NGX_MAIL_POP3_PROTOCOL:
-        p->upstream.connection->read->handler = ngx_mail_proxy_pop3_handler;
-        s->mail_state = ngx_pop3_start;
+        p->read->handler = ngx_mail_proxy_pop3_handler;
+	if (s->mail_state != ngx_pop3_stls)
+    	    s->mail_state = ngx_pop3_start;
         break;
 
     case NGX_MAIL_IMAP_PROTOCOL:
-        p->upstream.connection->read->handler = ngx_mail_proxy_imap_handler;
-        s->mail_state = ngx_imap_start;
+        p->read->handler = ngx_mail_proxy_imap_handler;
+	if (s->mail_state != ngx_imap_stls)
+	    s->mail_state = ngx_imap_start;
         break;
 
     default: /* NGX_MAIL_SMTP_PROTOCOL */
-        p->upstream.connection->read->handler = ngx_mail_proxy_smtp_handler;
-        s->mail_state = ngx_smtp_start;
+        p->read->handler = ngx_mail_proxy_smtp_handler;
+	if (s->mail_state != ngx_smtp_helo_xclient &&
+	    s->mail_state != ngx_smtp_helo_from &&
+	    s->mail_state != ngx_smtp_helo)
+    		    s->mail_state = ngx_smtp_start;
         break;
-    }
 }
-
+}
 
 static void
 ngx_mail_proxy_block_read(ngx_event_t *rev)
@@ -209,12 +289,79 @@ ngx_mail_proxy_block_read(ngx_event_t *r
     }
 }
 
+#if (NGX_MAIL_SSL)
+static ngx_int_t
+ngx_mail_proxy_handle_junk(ngx_connection_t *c)
+{
+    ngx_mail_session_t *s = c->data;
+    ngx_mail_proxy_ctx_t *p = s->proxy;
+    p->upstream.connection->read->pending_eof = 1;
+    
+    ssize_t len = p->buffer->end - p->buffer->last;
+    ssize_t rc;
+    ngx_int_t have_kqueue = 0;
+#if (NGX_HAVE_KQUEUE)
+    if (ngx_event_flags & NGX_USE_KQUEUE_EVENT)
+	have_kqueue = 1;
+#endif
+
+    if (!s->junk_flag) {
+	p->upstream.connection->read->pending_eof = 0;
+    
+	do {
+	    if (have_kqueue)
+    		len = p->upstream.connection->read->available;
+	    rc = p->upstream.connection->recv
+	      (p->upstream.connection, p->buffer->start, len);
+	    /* i can also modify ngx_unix_recv to return
+	     * explicit "not ready", but that will be
+	     * overengineering for such crappy task */
+	    if (rc == NGX_ERROR)
+		return rc;
+	    /* take what is here now */
+	    if (rc == NGX_AGAIN)
+		break;
+	} while(1);
+
+	/* designate our ssl junk by CR LF */
+	if (c->send(c, CRLF, 2) != 2)
+	    return NGX_ERROR;
+	
+	s->junk_flag = 1;
+	return ngx_mail_proxy_handle_junk(c);
+    } else {
+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+    		"blocking recv junk");
+	do {
+	    if (have_kqueue)
+		len = p->upstream.connection->read->available;
+	    rc = p->upstream.connection->recv
+	    (p->upstream.connection, p->buffer->start, len);
+	    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, s->connection->log,
+		    0, "recv ret: %d", rc);
+	    
+	    if (rc == NGX_ERROR || rc == 0) 
+		return NGX_ERROR;
+	    if (rc == NGX_AGAIN) {
+		/* must block */
+		return NGX_AGAIN;
+	    }
+	    break;
+	} while(1);
+
+	s->con_proto = NGX_MAIL_AUTH_PROTO_STLS;
+	p->upstream.connection->read->eof = 0;
+    }
+		    
+    return NGX_OK;
+}
+#endif
 
 static void
 ngx_mail_proxy_pop3_handler(ngx_event_t *rev)
 {
     u_char                 *p;
-    ngx_int_t               rc;
+    ngx_int_t               rc = NGX_OK;
     ngx_str_t               line;
     ngx_connection_t       *c;
     ngx_mail_session_t     *s;
@@ -234,18 +381,90 @@ ngx_mail_proxy_pop3_handler(ngx_event_t 
         return;
     }
 
+#if (NGX_MAIL_SSL)
+    ngx_int_t handshaked = 0;
+    if (c->ssl) if (c->ssl->handshaked) handshaked = 1;
+    if (s->con_proto == NGX_MAIL_AUTH_PROTO_SECURE && !handshaked) {
+	    /* take off response stayed after failed pop3s on pop3 port */
+	    if ( (rc = ngx_mail_proxy_handle_junk(c)) == NGX_OK)
+		    s->mail_state = ngx_imap_stls;
+    		    //s->mail_state = ngx_pop3_noop;
+    }
+    /* nothing to receive */
+    else if (s->con_proto == NGX_MAIL_AUTH_PROTO_STLS && handshaked &&
+		    s->mail_state == ngx_pop3_start)
+	    ;
+    else
+#endif
     rc = ngx_mail_proxy_read_response(s, 0);
 
+//#if (NGX_MAIL_SSL)
+    /* Not all of servers are RFC 1939 compliant, and even compliant may
+     * most probably 'll not allow NOOP in A-state, so give on then */
+    //if (s->mail_state == ngx_pop3_stls && rc == NGX_ERROR)
+	//rc = NGX_OK;
+//#endif
+	
     if (rc == NGX_AGAIN) {
         return;
     }
 
     if (rc == NGX_ERROR) {
+#if (NGX_MAIL_SSL)
+	/* not every server doing clean ssl shutdown */
+	if (c->ssl) {
+	    if (!handshaked)
+		c->ssl->no_wait_shutdown = c->ssl->no_send_shutdown = 1;
+	    ngx_ssl_shutdown(c);
+	    if (!handshaked) {
+		ngx_post_event(c->read, &ngx_posted_events);
+	    }
+	}
+#endif
         ngx_mail_proxy_upstream_error(s);
         return;
     }
 
     switch (s->mail_state) {
+#if (NGX_MAIL_SSL)
+    /*case ngx_pop3_noop:
+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0, "mail proxy send no op");
+
+        line.len = sizeof("NOOP") - 1 + 2;
+        line.data = ngx_pnalloc(c->pool, line.len);
+        if (line.data == NULL) {
+            ngx_mail_proxy_internal_server_error(s);
+            return;
+        }
+        p = ngx_cpymem(line.data, "NOOP", sizeof("NOOP") - 1);
+        *p++ = CR; *p = LF;
+        s->mail_state = ngx_pop3_stls;
+        break;*/
+    case ngx_pop3_stls:
+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0, "mail proxy send stls");
+	
+        line.len = sizeof("STLS") - 1 + 2;
+        line.data = ngx_pnalloc(c->pool, line.len);
+        if (line.data == NULL) {
+            ngx_mail_proxy_internal_server_error(s);
+            return;
+        }
+        p = ngx_cpymem(line.data, "STLS", sizeof("STLS") - 1);
+        *p++ = CR; *p = LF;
+	s->mail_state = ngx_pop3_stls_init;
+	break;
+   case ngx_pop3_stls_init:
+	ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0, "mail proxy init stls");
+   
+        s->connection->log->action = "starttls handshaking";
+        ngx_mail_ssl_conf_t *sslcf = ngx_mail_get_module_srv_conf(s,
+	    ngx_mail_ssl_module);
+        if (sslcf->ssl.ctx)
+                ngx_mail_ssl_init_connection(&sslcf->ssl,
+                    s->proxy->upstream.connection, NGX_MAIL_SECURE_DIR_OUT);
+	return;
+	/* c->read->handler != ngx_mail_proxy_pop3_handler */
+#endif
 
     case ngx_pop3_start:
         ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0, "mail proxy send user");
@@ -308,7 +527,7 @@ ngx_mail_proxy_pop3_handler(ngx_event_t 
 #endif
         break;
     }
-
+    
     if (c->send(c, line.data, line.len) < (ssize_t) line.len) {
         /*
          * we treat the incomplete sending as NGX_ERROR
@@ -327,7 +546,7 @@ static void
 ngx_mail_proxy_imap_handler(ngx_event_t *rev)
 {
     u_char                 *p;
-    ngx_int_t               rc;
+    ngx_int_t               rc = NGX_OK;
     ngx_str_t               line;
     ngx_connection_t       *c;
     ngx_mail_session_t     *s;
@@ -346,7 +565,18 @@ ngx_mail_proxy_imap_handler(ngx_event_t 
         ngx_mail_proxy_internal_server_error(s);
         return;
     }
-
+#if (NGX_MAIL_SSL)
+    ngx_int_t handshaked = 0;
+    if (c->ssl) if (c->ssl->handshaked) handshaked = 1;
+    if (s->con_proto == NGX_MAIL_AUTH_PROTO_SECURE && !handshaked) {
+	if ( (rc = ngx_mail_proxy_handle_junk(c)) == NGX_OK)
+	    s->mail_state = ngx_imap_stls;
+    }
+    else if (s->con_proto == NGX_MAIL_AUTH_PROTO_STLS && handshaked &&
+		    s->mail_state == ngx_imap_start)
+	    ;
+    else
+#endif
     rc = ngx_mail_proxy_read_response(s, s->mail_state);
 
     if (rc == NGX_AGAIN) {
@@ -354,11 +584,45 @@ ngx_mail_proxy_imap_handler(ngx_event_t 
     }
 
     if (rc == NGX_ERROR) {
+#if (NGX_MAIL_SSL)
+	if (c->ssl) {
+	    if (!handshaked)
+		c->ssl->no_wait_shutdown = c->ssl->no_send_shutdown = 1;
+	    ngx_ssl_shutdown(c);
+	    if (!handshaked) {
+		ngx_post_event(c->read, &ngx_posted_events);
+	    }
+	}
+#endif
         ngx_mail_proxy_upstream_error(s);
         return;
     }
 
     switch (s->mail_state) {
+#if (NGX_MAIL_SSL)
+    case ngx_imap_stls:
+	ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0, "mail proxy send stls");
+	
+	line.len = s->tag.len + sizeof("STARTTLS") - 1 + 2;
+	line.data = ngx_pnalloc(c->pool, line.len);
+	if (line.data == NULL) {
+	    ngx_mail_proxy_internal_server_error(s);
+	    return;
+	}
+	ngx_sprintf(line.data, "%VSTARTTLS" CRLF, &s->tag);
+	s->mail_state = ngx_imap_stls_init;
+	break;
+    case ngx_imap_stls_init:
+	ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0, "mail proxy init stls");
+	
+	s->connection->log->action = "starttls handshaking";
+	ngx_mail_ssl_conf_t *sslcf = ngx_mail_get_module_srv_conf(s,
+	    ngx_mail_ssl_module);
+	if (sslcf->ssl.ctx)
+		ngx_mail_ssl_init_connection(&sslcf->ssl,
+		    s->proxy->upstream.connection, NGX_MAIL_SECURE_DIR_OUT);
+	return;
+#endif
 
     case ngx_imap_start:
         ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
@@ -461,12 +725,12 @@ static void
 ngx_mail_proxy_smtp_handler(ngx_event_t *rev)
 {
     u_char                    *p;
-    ngx_int_t                  rc;
+    ngx_int_t                  rc = NGX_OK;
     ngx_str_t                  line;
     ngx_buf_t                 *b;
     ngx_connection_t          *c;
     ngx_mail_session_t        *s;
-    ngx_mail_proxy_conf_t     *pcf;
+    ngx_mail_proxy_conf_t     *pcf = NULL;
     ngx_mail_core_srv_conf_t  *cscf;
 
     ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
@@ -482,7 +746,19 @@ ngx_mail_proxy_smtp_handler(ngx_event_t 
         ngx_mail_proxy_internal_server_error(s);
         return;
     }
-
+#if (NGX_MAIL_SSL)
+    ngx_int_t handshaked = 0;
+    if (c->ssl) if (c->ssl->handshaked) handshaked = 1;
+    if (s->con_proto == NGX_MAIL_AUTH_PROTO_SECURE && !handshaked)
+	    rc = ngx_mail_proxy_handle_junk(c);
+    else if (s->con_proto == NGX_MAIL_AUTH_PROTO_STLS && handshaked &&
+		    (s->mail_state == ngx_smtp_xclient ||
+		     s->mail_state == ngx_smtp_helo_from ||
+		     s->mail_state == ngx_smtp_helo) 
+	    )
+	    ;
+    else
+#endif
     rc = ngx_mail_proxy_read_response(s, s->mail_state);
 
     if (rc == NGX_AGAIN) {
@@ -490,6 +766,16 @@ ngx_mail_proxy_smtp_handler(ngx_event_t 
     }
 
     if (rc == NGX_ERROR) {
+#if (NGX_MAIL_SSL)
+	if (c->ssl) {
+	    if (!handshaked)
+		c->ssl->no_wait_shutdown = c->ssl->no_send_shutdown = 1;
+	    ngx_ssl_shutdown(c);
+	    if (!handshaked) {
+		ngx_post_event(c->read, &ngx_posted_events);
+	    }
+	}
+#endif
         ngx_mail_proxy_upstream_error(s);
         return;
     }
@@ -519,6 +805,11 @@ ngx_mail_proxy_smtp_handler(ngx_event_t 
         p = ngx_cpymem(p, cscf->server_name.data, cscf->server_name.len);
         *p++ = CR; *p = LF;
 
+#if (NGX_MAIL_SSL)
+	if (s->con_proto == NGX_MAIL_AUTH_PROTO_STLS)
+	    s->mail_state = ngx_smtp_stls;
+	else
+#endif
         if (pcf->xclient) {
             s->mail_state = ngx_smtp_helo_xclient;
 
@@ -531,6 +822,39 @@ ngx_mail_proxy_smtp_handler(ngx_event_t 
 
         break;
 
+#if (NGX_MAIL_SSL)	
+    case ngx_smtp_stls:
+	ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0, "mail proxy send stls");
+	
+	line.len = sizeof("STARTTLS") - 1 + 2;
+	line.data = ngx_pnalloc(c->pool, line.len);
+	if (line.data == NULL) {
+	    ngx_mail_proxy_internal_server_error(s);
+	    return;
+	}
+	p = ngx_cpymem(line.data, "STARTTLS", sizeof("STARTTLS") - 1);
+	*p++ = CR; *p = LF;
+	s->mail_state = ngx_smtp_stls_init;
+	break;
+    case ngx_smtp_stls_init:
+	ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0, "mail proxy init stls");
+
+        pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
+        if (pcf->xclient)
+            s->mail_state = ngx_smtp_helo_xclient;
+        else if (s->auth_method == NGX_MAIL_AUTH_NONE)
+            s->mail_state = ngx_smtp_helo_from;
+        else s->mail_state = ngx_smtp_helo;
+	
+	s->connection->log->action = "starttls handshaking";
+	ngx_mail_ssl_conf_t *sslcf = ngx_mail_get_module_srv_conf(s,
+	    ngx_mail_ssl_module);
+	if (sslcf->ssl.ctx)
+		ngx_mail_ssl_init_connection(&sslcf->ssl,
+		    s->proxy->upstream.connection, NGX_MAIL_SECURE_DIR_OUT);
+	return;
+#endif	
+
     case ngx_smtp_helo_xclient:
         ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
                        "mail proxy send xclient");
@@ -740,6 +1064,9 @@ ngx_mail_proxy_read_response(ngx_mail_se
     }
 
     p = b->pos;
+#if (NGX_MAIL_HANDLE_GMAIL)
+    u_char *ptemp;
+#endif
 
     switch (s->protocol) {
 
@@ -753,6 +1080,9 @@ ngx_mail_proxy_read_response(ngx_mail_se
         switch (state) {
 
         case ngx_imap_start:
+#if (NGX_MAIL_SSL)
+	case ngx_imap_stls:
+#endif
             if (p[0] == '*' && p[1] == ' ' && p[2] == 'O' && p[3] == 'K') {
                 return NGX_OK;
             }
@@ -766,7 +1096,17 @@ ngx_mail_proxy_read_response(ngx_mail_se
             break;
 
         case ngx_imap_passwd:
+#if (NGX_MAIL_SSL)
+	case ngx_imap_stls_init:
+#endif
+#if (NGX_MAIL_HANDLE_GMAIL)
+	    *(b->last - 2) = '\0';
+	    /* pass & cut inappropriate unasked CAPABILITY answer */
+	    if ( (ptemp = ngx_strstrn(p, s->tag.data, s->tag.len - 1)) ) {
+		b->pos = p = ptemp;
+#else
             if (ngx_strncmp(p, s->tag.data, s->tag.len) == 0) {
+#endif
                 p += s->tag.len;
                 if (p[0] == 'O' && p[1] == 'K') {
                     return NGX_OK;
@@ -781,6 +1121,9 @@ ngx_mail_proxy_read_response(ngx_mail_se
         switch (state) {
 
         case ngx_smtp_start:
+#if (NGX_MAIL_SSL)
+	case ngx_smtp_stls_init:
+#endif
             if (p[0] == '2' && p[1] == '2' && p[2] == '0') {
                 return NGX_OK;
             }
@@ -790,6 +1133,9 @@ ngx_mail_proxy_read_response(ngx_mail_se
         case ngx_smtp_helo_xclient:
         case ngx_smtp_helo_from:
         case ngx_smtp_from:
+#if (NGX_MAIL_SSL)
+	case ngx_smtp_stls:
+#endif
             if (p[0] == '2' && p[1] == '5' && p[2] == '0') {
                 return NGX_OK;
             }
@@ -958,9 +1304,10 @@ ngx_mail_proxy_handler(ngx_event_t *ev)
 
     c->log->action = "proxying";
 
-    if ((s->connection->read->eof && s->buffer->pos == s->buffer->last)
+    if (
+    (s->connection->read->eof && s->buffer->pos == s->buffer->last)
         || (s->proxy->upstream.connection->read->eof
-            && s->proxy->buffer->pos == s->proxy->buffer->last)
+    	    && s->proxy->buffer->pos == s->proxy->buffer->last)
         || (s->connection->read->eof
             && s->proxy->upstream.connection->read->eof))
     {
@@ -968,7 +1315,7 @@ ngx_mail_proxy_handler(ngx_event_t *ev)
         c->log->action = NULL;
         ngx_log_error(NGX_LOG_INFO, c->log, 0, "proxied session done");
         c->log->action = action;
-
+	
         ngx_mail_proxy_close_session(s);
         return;
     }
@@ -1021,7 +1368,7 @@ ngx_mail_proxy_upstream_error(ngx_mail_s
 }
 
 
-static void
+void
 ngx_mail_proxy_internal_server_error(ngx_mail_session_t *s)
 {
     if (s->proxy->upstream.connection) {
